{"version":3,"sources":["../../../src/controllers/transition-manager.ts"],"names":["Transition","noop","TRANSITION_EVENTS","DEFAULT_EASING","t","DEFAULT_INTERRUPTION","BREAK","TransitionManager","constructor","opts","transition","time","settings","interpolator","startProps","endProps","duration","easing","viewport","interpolateProps","propsInTransition","getControllerState","props","getViewportProps","onViewStateChange","viewState","oldViewState","timeline","onStateChange","finalize","cancel","getViewportInTransition","processViewStateChange","nextProps","transitionTriggered","currentProps","_shouldIgnoreViewportChange","_isTransitionEnabled","inProgress","interruption","SNAP_TO_END","_triggerTransition","updateTransition","update","transitionDuration","transitionInterpolator","Boolean","_isUpdateDueToCurrentTransition","arePropsEqual","IGNORE","startViewstate","endViewStateProps","shortestPathFrom","getDuration","initialProps","initializeProps","transitionSettings","transitionEasing","transitionInterruption","start","end","onStart","onTransitionStart","onUpdate","_onTransitionUpdate","onInterrupt","_onTransitionEnd","onTransitionInterrupt","onEnd","onTransitionEnd","inTransition","callback","isZooming","isPanning","isRotating"],"mappings":"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","sourcesContent":["import Transition, {TransitionSettings as BaseTransitionSettings} from '../transitions/transition';\nimport TransitionInterpolator from '../transitions/transition-interpolator';\nimport type {IViewState} from './view-state';\n\nimport type {Timeline} from '@luma.gl/core';\nimport type {InteractionState} from './controller';\n\nconst noop = () => {};\n\nexport enum TRANSITION_EVENTS {\n  BREAK = 1,\n  SNAP_TO_END = 2,\n  IGNORE = 3\n}\n\nexport type TransitionProps = {\n  /** Transition duration in milliseconds, default value 0, implies no transition. When using `FlyToInterpolator`, it can also be set to `'auto'`. */\n  transitionDuration?: number | 'auto';\n  /** An interpolator object that defines the transition behavior between two viewports. */\n  transitionInterpolator?: TransitionInterpolator;\n  /** Easing function that can be used to achieve effects like \"Ease-In-Cubic\", \"Ease-Out-Cubic\", etc. Default value performs Linear easing. */\n  transitionEasing?: (t: number) => number;\n  /** Controls how to process a new view state change that occurs during an existing transition. */\n  transitionInterruption?: TRANSITION_EVENTS;\n  /** Callback fired when requested transition starts. */\n  onTransitionStart?: (transition: Transition) => void;\n  /** Callback fired when requested transition is interrupted. */\n  onTransitionInterrupt?: (transition: Transition) => void;\n  /** Callback fired when requested transition ends. */\n  onTransitionEnd?: (transition: Transition) => void;\n};\n\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\n\ntype TransitionSettings = BaseTransitionSettings & {\n  interpolator: TransitionInterpolator;\n  easing: (t: number) => number;\n  interruption: TRANSITION_EVENTS;\n  startProps: Record<string, any>;\n  endProps: Record<string, any>;\n};\n\nexport default class TransitionManager<ControllerState extends IViewState<ControllerState>> {\n  getControllerState: (props: any) => ControllerState;\n  props?: TransitionProps;\n  propsInTransition: Record<string, any> | null;\n  transition: Transition;\n  onViewStateChange: (params: {\n    viewState: Record<string, any>;\n    oldViewState: Record<string, any>;\n  }) => void;\n  onStateChange: (state: InteractionState) => void;\n\n  constructor(opts: {\n    timeline: Timeline;\n    getControllerState: (props: any) => ControllerState;\n    onViewStateChange?: (params: {\n      viewState: Record<string, any>;\n      oldViewState: Record<string, any>;\n    }) => void;\n    onStateChange?: (state: InteractionState) => void;\n  }) {\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new Transition(opts.timeline);\n\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n\n  finalize(): void {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition(): Record<string, any> | null {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps: TransitionProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n      if (this.transition.inProgress) {\n        const {interruption, endProps} = this.transition.settings as TransitionSettings;\n        startProps = {\n          ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END\n            ? endProps\n            : this.propsInTransition || currentProps)\n        };\n      }\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props: TransitionProps): boolean {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      ((transitionDuration as number) > 0 || transitionDuration === 'auto') &&\n      Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props: TransitionProps): boolean {\n    if (this.transition.inProgress && this.propsInTransition) {\n      return (this.transition.settings as TransitionSettings).interpolator.arePropsEqual(\n        props,\n        this.propsInTransition\n      );\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps: TransitionProps, nextProps: TransitionProps): boolean {\n    if (this.transition.inProgress) {\n      // Ignore update if it is requested to be ignored\n      return (\n        (this.transition.settings as TransitionSettings).interruption ===\n          TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return (nextProps.transitionInterpolator as TransitionInterpolator).arePropsEqual(\n        currentProps,\n        nextProps\n      );\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps: TransitionProps, endProps: TransitionProps): void {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const transitionInterpolator = endProps.transitionInterpolator as TransitionInterpolator;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : (endProps.transitionDuration as number);\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n\n    this.propsInTransition = {};\n    const transitionSettings: TransitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n\n    this.onStateChange({inTransition: true});\n\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback?: (transition: Transition) => void) {\n    return transition => {\n      this.propsInTransition = null;\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n\n      callback?.(transition);\n    };\n  }\n\n  _onTransitionUpdate = transition => {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = this.getControllerState({\n      ...this.props,\n      ...viewport\n    }).getViewportProps();\n\n    this.onViewStateChange({\n      viewState: this.propsInTransition,\n      oldViewState: this.props as TransitionProps\n    });\n  };\n}\n"],"file":"transition-manager.js"}