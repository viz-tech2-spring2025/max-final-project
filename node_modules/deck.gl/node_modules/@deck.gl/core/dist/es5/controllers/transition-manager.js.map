{"version":3,"sources":["../../../src/controllers/transition-manager.ts"],"names":["noop","TRANSITION_EVENTS","DEFAULT_EASING","t","DEFAULT_INTERRUPTION","BREAK","TransitionManager","opts","transition","time","settings","interpolator","startProps","endProps","duration","easing","viewport","interpolateProps","propsInTransition","getControllerState","props","getViewportProps","onViewStateChange","viewState","oldViewState","Transition","timeline","onStateChange","cancel","nextProps","transitionTriggered","currentProps","_shouldIgnoreViewportChange","_isTransitionEnabled","inProgress","interruption","SNAP_TO_END","_triggerTransition","update","transitionDuration","transitionInterpolator","Boolean","arePropsEqual","IGNORE","_isUpdateDueToCurrentTransition","startViewstate","endViewStateProps","shortestPathFrom","getDuration","initialProps","initializeProps","transitionSettings","transitionEasing","transitionInterruption","start","end","onStart","onTransitionStart","onUpdate","_onTransitionUpdate","onInterrupt","_onTransitionEnd","onTransitionInterrupt","onEnd","onTransitionEnd","inTransition","updateTransition","callback","isZooming","isPanning","isRotating"],"mappings":"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","sourcesContent":["import Transition, {TransitionSettings as BaseTransitionSettings} from '../transitions/transition';\nimport TransitionInterpolator from '../transitions/transition-interpolator';\nimport type {IViewState} from './view-state';\n\nimport type {Timeline} from '@luma.gl/core';\nimport type {InteractionState} from './controller';\n\nconst noop = () => {};\n\nexport enum TRANSITION_EVENTS {\n  BREAK = 1,\n  SNAP_TO_END = 2,\n  IGNORE = 3\n}\n\nexport type TransitionProps = {\n  /** Transition duration in milliseconds, default value 0, implies no transition. When using `FlyToInterpolator`, it can also be set to `'auto'`. */\n  transitionDuration?: number | 'auto';\n  /** An interpolator object that defines the transition behavior between two viewports. */\n  transitionInterpolator?: TransitionInterpolator;\n  /** Easing function that can be used to achieve effects like \"Ease-In-Cubic\", \"Ease-Out-Cubic\", etc. Default value performs Linear easing. */\n  transitionEasing?: (t: number) => number;\n  /** Controls how to process a new view state change that occurs during an existing transition. */\n  transitionInterruption?: TRANSITION_EVENTS;\n  /** Callback fired when requested transition starts. */\n  onTransitionStart?: (transition: Transition) => void;\n  /** Callback fired when requested transition is interrupted. */\n  onTransitionInterrupt?: (transition: Transition) => void;\n  /** Callback fired when requested transition ends. */\n  onTransitionEnd?: (transition: Transition) => void;\n};\n\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\n\ntype TransitionSettings = BaseTransitionSettings & {\n  interpolator: TransitionInterpolator;\n  easing: (t: number) => number;\n  interruption: TRANSITION_EVENTS;\n  startProps: Record<string, any>;\n  endProps: Record<string, any>;\n};\n\nexport default class TransitionManager<ControllerState extends IViewState<ControllerState>> {\n  getControllerState: (props: any) => ControllerState;\n  props?: TransitionProps;\n  propsInTransition: Record<string, any> | null;\n  transition: Transition;\n  onViewStateChange: (params: {\n    viewState: Record<string, any>;\n    oldViewState: Record<string, any>;\n  }) => void;\n  onStateChange: (state: InteractionState) => void;\n\n  constructor(opts: {\n    timeline: Timeline;\n    getControllerState: (props: any) => ControllerState;\n    onViewStateChange?: (params: {\n      viewState: Record<string, any>;\n      oldViewState: Record<string, any>;\n    }) => void;\n    onStateChange?: (state: InteractionState) => void;\n  }) {\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new Transition(opts.timeline);\n\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n\n  finalize(): void {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition(): Record<string, any> | null {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps: TransitionProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n      if (this.transition.inProgress) {\n        const {interruption, endProps} = this.transition.settings as TransitionSettings;\n        startProps = {\n          ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END\n            ? endProps\n            : this.propsInTransition || currentProps)\n        };\n      }\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props: TransitionProps): boolean {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      ((transitionDuration as number) > 0 || transitionDuration === 'auto') &&\n      Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props: TransitionProps): boolean {\n    if (this.transition.inProgress && this.propsInTransition) {\n      return (this.transition.settings as TransitionSettings).interpolator.arePropsEqual(\n        props,\n        this.propsInTransition\n      );\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps: TransitionProps, nextProps: TransitionProps): boolean {\n    if (this.transition.inProgress) {\n      // Ignore update if it is requested to be ignored\n      return (\n        (this.transition.settings as TransitionSettings).interruption ===\n          TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return (nextProps.transitionInterpolator as TransitionInterpolator).arePropsEqual(\n        currentProps,\n        nextProps\n      );\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps: TransitionProps, endProps: TransitionProps): void {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const transitionInterpolator = endProps.transitionInterpolator as TransitionInterpolator;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : (endProps.transitionDuration as number);\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n\n    this.propsInTransition = {};\n    const transitionSettings: TransitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n\n    this.onStateChange({inTransition: true});\n\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback?: (transition: Transition) => void) {\n    return transition => {\n      this.propsInTransition = null;\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n\n      callback?.(transition);\n    };\n  }\n\n  _onTransitionUpdate = transition => {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = this.getControllerState({\n      ...this.props,\n      ...viewport\n    }).getViewportProps();\n\n    this.onViewStateChange({\n      viewState: this.propsInTransition,\n      oldViewState: this.props as TransitionProps\n    });\n  };\n}\n"],"file":"transition-manager.js"}